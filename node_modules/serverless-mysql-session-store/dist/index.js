"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MySQLSessionStore = void 0;
const mysql2_1 = __importDefault(require("mysql2"));
const express_session_1 = require("express-session");
class MySQLSessionStore extends express_session_1.Store {
    constructor(config, tableName = 'sessions') {
        super();
        this.config = config;
        this.tableName = tableName;
        this.state = 'INITIALIZING';
        this.onReadyPromises = [];
        Promise.resolve()
            .then(() => {
            return this.createTableIfNotExists();
        })
            .then(() => {
            this.state = 'INITIALIZED';
            this.resolveReadyPromises();
        })
            .catch((error) => {
            this.state = "FAIL";
            this.rejectReadyPromises(error);
        });
    }
    onReady() {
        return new Promise((resolve, reject) => {
            if (this.state === 'INITIALIZED') {
                resolve();
            }
            else if (this.state === 'FAIL') {
                reject();
            }
            else {
                this.onReadyPromises.push((error) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve();
                    }
                });
            }
        });
    }
    resolveReadyPromises() {
        for (const resolve of this.onReadyPromises) {
            resolve();
        }
        this.onReadyPromises = [];
    }
    rejectReadyPromises(error) {
        for (const resolve of this.onReadyPromises) {
            resolve(error);
        }
        this.onReadyPromises = [];
    }
    queryAsync(query) {
        return new Promise(async (resolve, reject) => {
            let connection = await this.getConnection();
            connection.query(query, (err, results) => {
                connection.end();
                if (err) {
                    reject(err);
                }
                else {
                    resolve(results);
                }
            });
        });
    }
    ;
    async getConnection() {
        return new Promise((resolve, reject) => {
            const connection = mysql2_1.default.createConnection(this.config);
            connection.connect((err) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(connection);
                }
            });
        });
    }
    async isTableCreated() {
        const results = await this.queryAsync("SHOW TABLES");
        const tableNames = results.map(row => Object.values(row)[0]);
        return tableNames.includes(this.tableName);
    }
    async waitUntilTableExists(timeout = 6000) {
        const startTime = Date.now();
        const endTime = startTime + timeout;
        while (Date.now() < endTime) {
            try {
                if (await this.isTableCreated()) {
                    return;
                }
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            catch (e) {
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }
        throw new Error(`Timed out waiting for table ${this.tableName} to exist`);
    }
    createTableIfNotExists() {
        return new Promise((resolve, reject) => {
            Promise.resolve()
                .then(async () => {
                const createTableQuery = `
                        CREATE TABLE IF NOT EXISTS ${this.tableName} (
                            id VARCHAR(255) PRIMARY KEY,
                            session JSON NOT NULL,
                            expires TIMESTAMP(6) NOT NULL,
                            INDEX expires_idx (expires)
                        );    
                    `;
                try {
                    let result = await this.queryAsync(createTableQuery);
                    if (result.warningStatus == 0) {
                        await this.waitUntilTableExists();
                    }
                }
                catch (err) {
                    console.error(`Failed to create ${this.tableName} table:`, err);
                    throw err;
                }
                resolve();
            })
                .catch((err) => {
                console.error(`Failed to create ${this.tableName} table:`, err);
                reject(err);
            });
        });
    }
    async get(sessionId, callback) {
        try {
            await this.onReady();
            const connection = await this.getConnection();
            const query = `SELECT session FROM ${this.tableName} WHERE id = ? AND expires >= CURRENT_TIMESTAMP(6)`;
            connection.query(query, [sessionId], (err, results) => {
                connection.end();
                if (err) {
                    throw err;
                }
                else if (results.length === 0) {
                    callback(null, null);
                }
                else {
                    const sessionData = results[0].session;
                    callback(null, sessionData);
                }
            });
        }
        catch (err) {
            callback(err);
        }
    }
    async set(sessionId, session, callback) {
        try {
            await this.onReady();
            const connection = await this.getConnection();
            const expires = session.cookie.expires
                ? session.cookie.expires.toISOString().slice(0, -1)
                : new Date(Date.now() + session.cookie.maxAge).toISOString().slice(0, -1);
            const query = `
                    INSERT INTO ${this.tableName} (id, session, expires)
                    VALUES (?, ?, ?)
                    ON DUPLICATE KEY UPDATE session = ?, expires = ?;
                    `;
            connection.query(query, [sessionId, JSON.stringify(session), expires, JSON.stringify(session), expires], (err) => {
                connection.end();
                if (callback) {
                    callback(err);
                }
            });
        }
        catch (err) {
            if (callback) {
                callback(err);
            }
        }
    }
    async touch(sessionId, session, callback) {
        try {
            await this.onReady();
            const connection = await this.getConnection();
            const expires = session.cookie.expires
                ? session.cookie.expires.toISOString().slice(0, -1)
                : new Date(Date.now() + session.cookie.maxAge).toISOString().slice(0, -1);
            const query = `
                UPDATE ${this.tableName}
                SET expires = ?
                WHERE id = ? AND expires >= CURRENT_TIMESTAMP(6);
            `;
            connection.query(query, [expires, sessionId], (err) => {
                connection.end();
                if (callback) {
                    callback(err);
                }
            });
        }
        catch (err) {
            if (callback) {
                callback(err);
            }
        }
    }
    async destroy(sessionId, callback) {
        try {
            await this.onReady();
            const connection = await this.getConnection();
            const query = `DELETE FROM ${this.tableName} WHERE id = ?`;
            connection.query(query, [sessionId], (err) => {
                connection.end();
                if (callback) {
                    callback(err);
                }
            });
        }
        catch (err) {
            if (callback) {
                callback(err);
            }
        }
    }
    async length(callback) {
        try {
            await this.onReady();
            const connection = await this.getConnection();
            const query = `SELECT COUNT(*) as count FROM ${this.tableName} WHERE expires >= CURRENT_TIMESTAMP(6)`;
            connection.query(query, (err, results) => {
                connection.end();
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, results[0].count);
                }
            });
        }
        catch (err) {
            callback(err);
        }
    }
    async clear(callback) {
        try {
            await this.onReady();
            const connection = await this.getConnection();
            const query = `DELETE FROM ${this.tableName}`;
            connection.query(query, (err) => {
                connection.end();
                if (callback) {
                    callback(err);
                }
            });
        }
        catch (err) {
            if (callback) {
                callback(err);
            }
        }
    }
    async reap() {
        try {
            await this.onReady();
            const connection = await this.getConnection();
            const query = `DELETE FROM ${this.tableName} WHERE expires < CURRENT_TIMESTAMP(6)`;
            connection.query(query, (err) => {
                connection.end();
                if (err) {
                    console.error('Failed to clean up expired sessions:', err);
                }
                else {
                    console.log('Expired sessions cleaned up');
                }
            });
        }
        catch (err) {
            console.error(err);
        }
    }
}
exports.MySQLSessionStore = MySQLSessionStore;
